/*
 * Copyright 2012-2015 Tobi29
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.stream.Collectors

apply from: "$rootDir/resources/scapesenginemodule.gradle"

configurations {
    runtimeLinux32
    runtimeLinux64
    runtimeMacOSX
    runtimeWindows32
    runtimeWindows64
    runtimePlatform
    nativesLinux32
    nativesLinux64
    nativesMacOSX
    nativesWindows32
    nativesWindows64
    nativesPlatform

    String os = System.properties["os.name"].toLowerCase()
    String arch = System.properties["os.arch"]
    if (os.contains("linux")) {
        if (arch.contains("64")) {
            runtimePlatform.extendsFrom runtimeLinux64
            nativesPlatform.extendsFrom nativesLinux64
        } else {
            runtimePlatform.extendsFrom runtimeLinux32
            nativesPlatform.extendsFrom nativesLinux32
        }
    } else if (os.contains("mac")) {
        runtimePlatform.extendsFrom runtimeMacOSX
        nativesPlatform.extendsFrom nativesMacOSX
    } else if (os.contains("windows")) {
        if (arch.contains("64")) {
            runtimePlatform.extendsFrom runtimeWindows64
            nativesPlatform.extendsFrom nativesWindows64
        } else {
            runtimePlatform.extendsFrom runtimeWindows32
            nativesPlatform.extendsFrom nativesWindows32
        }
    }
}

afterEvaluate {
    sourceSets.main.runtimeClasspath += configurations.runtimePlatform

    idea {
        module {
            scopes.RUNTIME.plus += [configurations.runtimePlatform]
        }
    }
}

apply plugin: ScapesEngineApplication

class ScapesEngineApplication implements Plugin<Project> {
    private ScapesEngineApplicationExtension appExtension

    @Override
    void apply(Project target) {
        // Application properties
        target.extensions.
                create("application", ScapesEngineApplicationExtension)

        // Natives task
        Copy nativesTask = target.tasks.create("natives", Copy)
        nativesTask.description = "Extract natives for runtime"
        nativesTask.group = "run"
        nativesTask.from { ->
            target.configurations.nativesPlatform.files.stream().
                    map({ target.zipTree(it) }).
                    collect(Collectors.toList())
        }
        nativesTask.into new File(target.buildDir, "natives")

        // Run task
        Task runTask = target.tasks.create("run", JavaExec)
        runTask.description = "Runs this project as a JVM application"
        runTask.group = "Run"
        runTask.conventionMapping.main = { target.application.mainClass }
        target.afterEvaluate {
            runTask.classpath = target.sourceSets.main.runtimeClasspath
        }
        runTask.jvmArgs "-Xms1024M", "-Xmx2048M", "-XX:+UseG1GC",
                "-XX:MaxGCPauseMillis=1"
        if (target.hasProperty("runArgs")) {
            runTask.args Eval.me(target.runArgs)
        }
        if (target.hasProperty("jvmArgs")) {
            runTask.jvmArgs Eval.me(target.jvmArgs)
        }
        if (System.properties["os.name"].toLowerCase().contains("mac")) {
            runTask.jvmArgs "-XstartOnFirstThread"
        }
        runTask.standardInput = System.in
        runTask.dependsOn target.classes

        // Platform deploy tasks
        Task deployUniversalTask = addDeployUniversalTask(target)
        Task deployMacOSXTask = addDeployMacOSXTask(target)
        Task deployWindowsTask = addDeployWindowsTask(target)

        // Full deploy task
        Task deployTask = target.tasks.create("deploy", Task)
        deployTask.group = "Deployment"
        if (deployUniversalTask != null) {
            deployTask.dependsOn deployUniversalTask
        }
        if (deployMacOSXTask != null) {
            deployTask.dependsOn deployMacOSXTask
        }
        if (deployWindowsTask != null) {
            deployTask.dependsOn deployWindowsTask
        }
    }

    private Task addDeployUniversalTask(Project target) {
        // Main task
        Tar task = target.tasks.create("deployUniversal", Tar)
        task.description =
                "Contains platform-independent files useful for creating packages"
        task.group = "Deployment"
        task.dependsOn target.jar
        task.baseName = "${-> target.project.name}-Universal"
        task.compression = Compression.GZIP
        task.from(target.configurations.runtime)
        task.from(target.jar)
        return task
    }

    private Task addDeployMacOSXTask(Project target) {
        File jre = getJRE(target, "MacOSX")
        if (jre == null) {
            target.logger.warn "No JRE for Mac OS X found!"
            return
        }
        pruneJREMacOSX(jre)
        // Bundle task
        AppBundlerTask bundleTask = target.tasks.
                create("bundleMacOSX", AppBundlerTask)
        bundleTask.dependsOn target.jar
        bundleTask.fullName = "${-> target.application.fullName}"
        bundleTask.version = "${-> target.application.version}"
        bundleTask.company = "${-> target.application.company}"
        bundleTask.copyright = "${-> target.application.copyright}"
        bundleTask.mainClass = "${-> target.application.mainClass}"
        bundleTask.appbundler =
                target.rootProject.file("resources/appbundler-1.0ea.jar")
        bundleTask.jre = jre
        bundleTask.icon = target.file("project/Icon.icns")
        bundleTask.classpath = target.configurations.runtime +
                target.configurations.runtimeMacOSX + target.files(target.jar)
        bundleTask.output =
                "${-> bundleTask.temporaryDir}/${-> target.project.name}.app"

        // Natives task
        Copy nativesTask = target.tasks.create("nativesMacOSX", Copy)
        nativesTask.dependsOn bundleTask
        nativesTask.from({ ->
            target.configurations.nativesMacOSX.files.stream().
                    map({ target.zipTree(it) }).collect(Collectors.toList())
        })
        nativesTask.into "${-> bundleTask.output}/Contents/MacOS"

        // Main task
        Tar task = target.tasks.create("deployMacOSX", Tar)
        task.description =
                "Mac OS X Application containing necessary files to run the game"
        task.group = "Deployment"
        task.dependsOn nativesTask
        task.baseName = "${target.project.name}-MacOSX"
        task.compression = Compression.GZIP
        task.from bundleTask.output.parentFile
        return task
    }

    private Task addDeployWindowsTask(Project target) {
        File jre32 = new File(target.buildDir,
                "tmp/prepareWindows/install/32/jre")
        if (!jre32.exists()) {
            File extracted = getJRE(target, "Windows/32", jre32.parentFile)
            if (extracted == null) {
                target.logger.warn "No 32-Bit JRE for Windows found!"
                return
            }
            pruneJREWindows(extracted)
            extracted.renameTo(jre32)
        }
        File jre64 = new File(target.buildDir,
                "tmp/prepareWindows/install/64/jre")
        if (!jre64.exists()) {
            File extracted = getJRE(target, "Windows/64", jre64.parentFile)
            if (extracted == null) {
                target.logger.warn "No 64-Bit JRE for Windows found!"
                return
            }
            pruneJREWindows(extracted)
            extracted.renameTo(jre64)
        }

        // Program task
        Launch4jTask programTask = target.tasks.
                create("programWindows", Launch4jTask)
        programTask.fullName = "${-> target.application.fullName}"
        programTask.version = "${-> target.application.version}"
        programTask.company = "${-> target.application.company}"
        programTask.copyright = "${-> target.application.copyright}"
        programTask.mainClass = "${-> target.application.mainClass}"
        programTask.launch4j =
                target.rootProject.file("resources/Launch4j/launch4j.jar")
        programTask.icon = target.file("project/Icon.ico")
        programTask.exeMemoryMin = 1024
        programTask.exeMemoryMax = 2048
        programTask.exeType = "gui"
        programTask.runInAppData = true
        programTask.manifest =
                target.rootProject.file("resources/Program.manifest")
        programTask.output = new File(programTask.temporaryDir,
                target.project.name + ".exe")

        // Command task
        Launch4jTask programCmdTask = target.tasks.
                create("programCmdWindows", Launch4jTask)
        programCmdTask.fullName = "${-> target.application.fullName}"
        programCmdTask.version = "${-> target.application.version}"
        programCmdTask.company = "${-> target.application.company}"
        programCmdTask.copyright = "${-> target.application.copyright}"
        programCmdTask.mainClass = "${-> target.application.mainClass}"
        programCmdTask.launch4j =
                target.rootProject.file("resources/Launch4j/launch4j.jar")
        programCmdTask.icon = target.file("project/Icon.ico")
        programCmdTask.exeMemoryMin = 1024
        programCmdTask.exeMemoryMax = 2048
        programCmdTask.exeType = "console"
        programCmdTask.runInAppData = false
        programCmdTask.manifest =
                target.rootProject.file("resources/Program.manifest")
        programCmdTask.output = new File(programCmdTask.temporaryDir,
                target.project.name + "Cmd.exe")

        // InnoSetup Config Task
        InnoSetupConfigTask isconfigTask = target.tasks.
                create("isconfigWindows", InnoSetupConfigTask)
        isconfigTask.config = target.rootProject.file("resources/Setup.iss")
        isconfigTask.output = new File(isconfigTask.temporaryDir, "Setup.iss")

        // Prepare Task
        Copy prepareTask = target.tasks.create("prepareWindows", Copy)
        prepareTask.dependsOn target.jar
        prepareTask.dependsOn programTask
        prepareTask.dependsOn programCmdTask
        prepareTask.dependsOn isconfigTask
        prepareTask.from isconfigTask.output
        prepareTask.from target.file("project/installer")
        prepareTask.from(programTask.output, { into "install/common" })
        prepareTask.from(programCmdTask.output, { into "install/common" })
        prepareTask.from(target.files(target.jar),
                { into "install/common/lib" })
        prepareTask.from(target.configurations.runtime,
                { into "install/common/lib" })
        prepareTask.from({ ->
            target.configurations.nativesWindows32.files.stream().
                    map({ target.zipTree(it) }).collect(Collectors.toList())
        }, { into "install/32" })
        prepareTask.from({ ->
            target.configurations.nativesWindows64.files.stream().
                    map({ target.zipTree(it) }).collect(Collectors.toList())
        }, { into "install/64" })
        prepareTask.from(target.configurations.runtimeWindows32,
                { into "install/32/lib" })
        prepareTask.from(target.configurations.runtimeWindows64,
                { into "install/64/lib" })
        prepareTask.from(target.rootProject.
                file("resources/Install/Windows"), { into "install" })
        prepareTask.into prepareTask.temporaryDir

        // Pack task
        Exec packTask = target.tasks.create("packWindows", Exec)
        packTask.dependsOn prepareTask
        String innoEXE = target.rootProject.
                file("resources/Inno Setup 5/ISCC.exe").absolutePath
        String innoISS = new File(prepareTask.temporaryDir,
                "Setup.iss").absolutePath
        if (System.properties["os.name"].toLowerCase().contains("win")) {
            packTask.commandLine innoEXE, innoISS
        } else {
            packTask.commandLine "wine", innoEXE, "Z:${innoISS}"
        }

        // Main task
        Copy task = target.tasks.create("deployWindows", Copy)
        task.dependsOn packTask
        task.group = "Deployment"
        task.description = "Windows Installer with bundled JRE"
        task.from new File(prepareTask.temporaryDir, "output/setup.exe")
        task.rename({
            "${-> target.project.name}-Setup-${-> target.project.version}.exe"
        })
        task.into new File(target.buildDir, "distributions")
        return task
    }

    private
    static File getJRE(Project target, String platform) {
        return getJRE(target, platform,
                new File(target.buildDir, "jres/" + platform))
    }

    private
    static File getJRE(Project target, String platform, File file) {
        File[] jres = target.rootProject.file("resources/JRE/" + platform).
                listFiles((FileFilter) {
                    !it.isDirectory() && !it.isHidden()
                })
        if (jres == null || jres.length == 0) {
            return null
        }
        // Workaround for automatic expanding failing on 2nd build
        if (!file.exists()) {
            target.copy {
                from {
                    target.tarTree(jres[0])
                }
                into file
            }
        }
        File[] jre = file.listFiles((FileFilter) {
            it.isDirectory() && !it.isHidden()
        })
        if (jre == null || jre.length == 0) {
            return null
        }
        return jre[0]
    }
    private static
    final List<String> jreExtensions = ["dnsns.jar", "sunjce_provider.jar",
            "sunec.jar", "sunpkcs11.jar", "sunmscapi.jar"]

    private static void pruneJREMacOSX(File jre) {
        File jreHome = new File(jre, "Contents/Home")
        pruneJRE(jreHome)
        File lib = new File(jreHome, "lib")
        deleteLibrary(lib, "libdecora_sse")
        deleteLibrary(lib, "libfxplugins")
        deleteLibrary(lib, "libglass")
        deleteLibrary(lib, "libglib-lite")
        deleteLibrary(lib, "libgstreamer-lite")
        deleteLibrary(lib, "libjavafx_font")
        deleteLibrary(lib, "libjavafx_font_t2k")
        deleteLibrary(lib, "libjavafx_iio")
        deleteLibrary(lib, "libjfxmedia")
        deleteLibrary(lib, "libjfxwebkit")
        deleteLibrary(lib, "libprism_common")
        deleteLibrary(lib, "libprism_es2")
        deleteLibrary(lib, "libprism_sw")
    }

    private static void pruneJREWindows(File jre) {
        pruneJRE(jre)
        File lib = new File(jre, "lib")
        File bin = new File(jre, "bin")
        delete(bin, "dtplugin")
        delete(bin, "plugin2")
        deleteBinary(bin, "javacpl")
        deleteBinary(bin, "jucheck")
        deleteBinary(bin, "jabswitch")
        deleteBinary(bin, "kinit")
        deleteBinary(bin, "klist")
        deleteBinary(bin, "ktab")
        deleteLibrary(bin, "java_crw_demo")
        deleteLibrary(bin, "JavaAccessBridge-32")
        deleteLibrary(bin, "JavaAccessBridge")
        deleteLibrary(bin, "JAWTAccessBridge-32")
        deleteLibrary(bin, "JAWTAccessBridge")
        deleteLibrary(bin, "WindowsAccessBridge-32")
        deleteLibrary(bin, "WindowsAccessBridge")
        deleteLibrary(bin, "wsdetect")
        deleteLibrary(bin, "deploy")
        deleteLibrary(bin, "jfr")
        deleteLibrary(bin, "decora_sse")
        deleteLibrary(bin, "fxplugins")
        deleteLibrary(bin, "glass")
        deleteLibrary(bin, "glib-lite")
        deleteLibrary(bin, "gstreamer-lite")
        deleteLibrary(bin, "javafx_font")
        deleteLibrary(bin, "javafx_font_t2k")
        deleteLibrary(bin, "javafx_iio")
        deleteLibrary(bin, "jfxmedia")
        deleteLibrary(bin, "jfxwebkit")
        deleteLibrary(bin, "prism_common")
        deleteLibrary(bin, "prism_d3d")
        deleteLibrary(bin, "prism_es2")
        deleteLibrary(bin, "prism_sw")

        delete(lib, "deploy.jar")
        delete(lib, "plugin.jar")
        delete(lib, "deploy")
    }

    private static void pruneJRE(File jre) {
        File lib = new File(jre, "lib")
        File bin = new File(jre, "bin")
        File ext = new File(lib, "ext")
        File[] unusedExtensions = ext.listFiles((FileFilter) {
            !jreExtensions.contains(it.name)
        })
        if (unusedExtensions != null) {
            for (File file : unusedExtensions) {
                file.delete()
            }
        }
        delete(jre, "THIRDPARTYLICENSEREADME-JAVAFX.txt")
        delete(jre, "plugin")

        delete(bin, "javacpl.cpl")
        deleteBinary(bin, "rmid")
        deleteBinary(bin, "rmiregistry")
        deleteBinary(bin, "tnameserv")
        deleteBinary(bin, "keytool")
        deleteBinary(bin, "policytool")
        deleteBinary(bin, "orbd")
        deleteBinary(bin, "servertool")
        deleteBinary(bin, "javaws")

        delete(lib, "javaws.jar")
        delete(lib, "jfr")
        delete(lib, "jfr.jar")
        delete(lib, "oblique-fonts")
        delete(lib, "desktop")
        delete(lib, "ant-javafx.jar")
        delete(lib, "javafx.properties")
        delete(lib, "jfxswt.jar")
    }

    private static void delete(File dir, String name) {
        File file = new File(dir, name)
        if (file.isDirectory()) {
            file.deleteDir()
        } else {
            file.delete()
        }
    }

    private static void deleteBinary(File dir, String name) {
        File file = new File(dir, name)
        file.delete()
        new File(file.parentFile, file.name + ".exe").delete()
    }

    private static void deleteLibrary(File dir, String name) {
        File file = new File(dir, name)
        file.delete()
        new File(file.parentFile, file.name + ".dll").delete()
        new File(file.parentFile, file.name + ".so").delete()
        new File(file.parentFile, file.name + ".dylib").delete()
    }
}

class ScapesEngineApplicationExtension {
    def String fullName
    def String version
    def String company
    def String url
    def String copyright
    def String uuid
    def String mainClass
}

class InnoSetupConfigTask extends DefaultTask {
    @InputFile
    def File config
    @OutputFile
    def File output

    @TaskAction
    void run() {
        BufferedWriter writer = output.newWriter()
        writer.write "#define ApplicationFullName \"${project.application.fullName}\"\n"
        writer.write "#define ApplicationVersion \"${project.application.version}\"\n"
        writer.write "#define ApplicationCompany \"${project.application.company}\"\n"
        writer.write "#define ApplicationCopyright \"${project.application.copyright}\"\n"
        writer.write "#define ApplicationURL \"${project.application.url}\"\n"
        writer.write "#define ApplicationUUID \"${project.application.uuid}\"\n"
        writer.write "#define ApplicationName \"${project.name}.exe\"\n"
        writer << config.newReader()
        writer.close()
    }
}

class AppBundlerTask extends DefaultTask {
    def String output
    @Input
    def fullName, version, company, copyright, mainClass
    @InputDirectory
    def File jre
    @InputFile
    def File appbundler, icon
    @InputFiles
    def FileCollection classpath

    @OutputDirectory
    File getOutput() {
        project.file(output)
    }

    @TaskAction
    void run() {
        File outputFile = getOutput()
        ant.taskdef(name: "bundleapp",
                classpath: appbundler.absolutePath,
                classname: "com.oracle.appbundler.AppBundlerTask")
        ant.bundleapp(outputdirectory: outputFile.parentFile.absolutePath,
                name: outputFile.name - ".app",
                displayname: fullName,
                identifier: "org.tobi29.scapes.engine",
                shortversion: version,
                icon: icon.absolutePath,
                mainclassname: mainClass,
                copyright: copyright,
                applicationCategory: "public.app-category.games",
                executableName: fullName) {
            classpath.addToAntBuilder(ant, "classpath",
                    FileCollection.AntType.FileSet)
            arch(name: "x86_64")
            runtime(dir: jre.absolutePath + "/Contents/Home")
            option(value: "-XstartOnFirstThread")
            option(value: "-Xms1024M")
            option(value: "-Xmx2048M")
            option(value: "-XX:+UseG1GC")
            option(value: "-XX:MaxGCPauseMillis=1")
            option(value: "-Xdock:icon=Contents/resources/Icon.icns")
            argument(value: "\$HOME/Library/Application Support/$fullName")
        }
    }
}

class Launch4jTask extends DefaultTask {
    def File output
    @Input
    def exeMemoryMin, exeMemoryMax, exeType, fullName, version, company, copyright, mainClass
    @Input
    boolean runInAppData
    @InputFile
    def File launch4j, icon, manifest

    @OutputFile
    File getOutput() {
        project.file(output)
    }

    @TaskAction
    void run() {
        ant.taskdef(name: "launch4j",
                classpath: launch4j.absolutePath,
                classname: "net.sf.launch4j.ant.Launch4jTask")
        def winVersion = version.replaceAll("_", ".")
        Map<String, String> configMap = [headerType: exeType,
                outfile: getOutput().absolutePath,
                dontWrapJar: "true",
                icon: icon.absolutePath,
                manifest: manifest.absolutePath]
        Map<String, String> versionMap = [fileversion: winVersion,
                txtfileversion: version,
                filedescription: fullName,
                copyright: copyright,
                productversion: winVersion,
                productname: fullName,
                txtproductversion: version,
                companyname: company,
                internalname: fullName,
                originalfilename: output.name]
        Map<String, String> classPathMap = [mainClass: mainClass,
                cp: "%EXEDIR%\\lib\\*"];
        Map<String, String> jreMap = [initialheapsize: exeMemoryMin,
                maxheapsize: exeMemoryMax,
                path: "%EXEDIR%\\jre"]
        if (runInAppData) {
            ant.launch4j {
                config(configMap) {
                    classPath(classPathMap)
                    jre(jreMap) {
                        opt("-Duser.dir=\"%APPDATA%\\${fullName}\"")
                        opt("-Djava.library.path=\"%EXEDIR%\"")
                    }
                    versioninfo(versionMap)
                }
            }
        } else {
            ant.launch4j {
                config(configMap) {
                    classPath(classPathMap)
                    jre(jreMap)
                    versioninfo(versionMap)
                }
            }
        }
    }
}
