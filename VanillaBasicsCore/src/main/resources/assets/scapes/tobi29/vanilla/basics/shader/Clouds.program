uniform 1 Matrix4 uniform_ModelViewProjectionMatrix;
uniform 3 Texture2 uniform_Texture;
uniform 4 Float uniform_Time;
uniform 5 Float uniform_Weather;
uniform 6 Vector2 uniform_CamPos;

const Vector4 pParam = vector4( 17.0*17.0, 34.0, 1.0, 7.0);

fun Vector4 permute(Vector4 x0,Vector3 p) {
  Vector4 x1 = x0 * p.y % p.x;
  return(floor((x1 + p.z) * x0 % p.x));
}

fun Float taylorInvSqrt(Float r) {
  return( 0.83666002653408 + 0.7*0.85373472095314 - 0.85373472095314 * r );
}

fun Float simplexNoise3(Vector3 v) {
  const Vector2  C = vector2(1./6.0 , 1./3.0 ) ;
  const Vector4  D = vector4(0., 0.5, 1.0, 2.0);

// First corner
  Vector3 i  = floor(v + dot(v, C.yyy) );
  Vector3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  Vector3 g = vector3( greaterThan(   x0.xyz, x0.yzx) );
  Vector3 l = vector3( lessThanEqual( x0.xyz, x0.yzx) );

  Vector3 i1 = g.xyz  * l.zxy;
  Vector3 i2 = max( g.xyz, l.zxy);

  Vector3 x1 = x0 - i1 + 1.0 * C.xxx;
  Vector3 x2 = x0 - i2 + 2.0 * C.xxx;
  Vector3 x3 = x0 - 1.0 + 3.0 * C.xxx;

// Permutations
  i = i % pParam.x;
  Vector4 p = permute( permute( permute(
             i.z + vector4(0.0, i1.z, i2.z, 1.0 ), pParam.xyz)
           + i.y + vector4(0.0, i1.y, i2.y, 1.0 ), pParam.xyz)
           + i.x + vector4(0.0, i1.x, i2.x, 1.0 ), pParam.xyz);

// Gradients
// ( N*N points uniformly over a square, mapped onto a octohedron.)
  Float n_ = 1.0/pParam.w ;
  Vector3  ns = n_ * D.wyz - D.xzx ;

  Vector4 j = p - pParam.w*pParam.w*floor(p * ns.z *ns.z);  //  mod(p,N*N)

  Vector4 x_ = floor(j * ns.z)  ;
  Vector4 y_ = floor(j - pParam.w * x_ ) ;    // mod(j,N)

  Vector4 x = x_ *ns.x + ns.yyyy;
  Vector4 y = y_ *ns.x + ns.yyyy;
  Vector4 h = 1.0 - abs(x) - abs(y);

  Vector4 b0 = vector4( x.xy, y.xy );
  Vector4 b1 = vector4( x.zw, y.zw );

  Vector4 s0 = vector4(lessThan(b0,D.xxxx)) *2.0 -1.;
  Vector4 s1 = vector4(lessThan(b1,D.xxxx)) *2.0 -1.;
  Vector4 sh = vector4(lessThan(h, D.xxxx));

  Vector4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  Vector4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  Vector3 p0 = vector3(a0.xy,h.x);
  Vector3 p1 = vector3(a0.zw,h.y);
  Vector3 p2 = vector3(a1.xy,h.z);
  Vector3 p3 = vector3(a1.zw,h.w);

  p0 *= taylorInvSqrt(dot(p0,p0));
  p1 *= taylorInvSqrt(dot(p1,p1));
  p2 *= taylorInvSqrt(dot(p2,p2));
  p3 *= taylorInvSqrt(dot(p3,p3));

// Mix
  Vector4 m = max(0.6 - vector4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);
  m = m * m;
//used to be 64.
  return(48.0 * dot( m*m, vector4( dot(p0,x0), dot(p1,x1),
                                dot(p2,x2), dot(p3,x3) ) ));
}

shader vertex(0 Vector4 attribute_Position,
              2 Vector2 attribute_Texture) {
    varying_Texture = attribute_Texture;
    out_Position = uniform_ModelViewProjectionMatrix * attribute_Position;
}

shader fragment(Vector2 varying_Texture) {
    Vector2 pos = varying_Texture + uniform_CamPos;
    Float n = min(abs(simplexNoise3(vector3(pos.x * 10.0, pos.y * 10.0, uniform_Time)) * 1.5 + simplexNoise3(vector3(pos.x * 200.0, pos.y * 200.0, uniform_Time)) * 0.5), 1.0);
    Float a = clamp(simplexNoise3(vector3(pos.x * 3.0, pos.y * 3.0, uniform_Time)) - 0.9 + uniform_Weather * 3.0 - n * 0.02, 0.0, 1.0);
    out_Color.a = clamp(a * 1.4, 0.0, 1.0);
    if (out_Color.a <= 0.01) {
        discard();
    }
    out_Color.rgb = vector3(clamp(2.0 - a * 1.6 - n * 0.1 - max(uniform_Weather * 2.0 - 1.0, 0.0), 0.0, 1.0));
}

outputs(0 Vector4 out_Color);